# JavaScript 设计模式

__前言__:看起来设计模式是很难的，但有一部分都是自己平时书写的方式，多看设计模式，有利于更稳更快地写代码

## 构造器模式

>特点：

    通过在构造器前面前面加new关键字，像使用构造器一样实例化一个新对象，对象成员由该函数定义
>写法：

    一个带参数的构造函数定义变量，通过函数的原型链来定义,我之前所写的构造函数的protype定义不太好会重写原型链

## Module（模块）模式

>特点：

    js中为类提供私有和共有封装的方法，封装起来是为了避免污染全局，有点儿命名空间的意思

>写法：

    一个立即函数定义在一个变量里，通过return接口出来的都是公有方法和公有变量，其他为私有不可访问

>变式（Revealing Module）：

    将暴露的共有指针指向私有函数和属性上，为了在私有范围内简单定义所有函数和变量，并返回一个匿名对象，外部通过自行定义的共有方法使用

## Singleton（单例）模式

>特点：

    实例不存在的时候，可以通过一个方法创建一个类来实现创建类的实例，如果已存在，简单返回对该对象的引用。

>场景：

    在JavaScript中，Singleton充当共享资源命名空间，为函数提供单一访问点

## Observer（观察者）模式

>特点：

    一个subject由多个观察者观察变化，目标状态发生改变并且观察者可能对这些改变感兴趣就会发一个通知消息，调用每个观察者的更新方法，观察者们不感兴趣时可从目标中分离
>组成：

    1、Subject
    2、Observer
    3、ConcreteSubject
    4、ConcreteObserver

>区分于：

    Publish/Subscribe是单向从Subscriber改变event Channel（Subscribe，fire event），Observer是observer可观察subject，subject可消去observer，双向

## Mediator（中介者）模式

>特点：

    公开一个统一的接口，系统的不同部分可以通过接口进行通信

>优点：

    通信渠道由多对多减少到多对一，解耦程度较高，添加新发布者和订阅者也容易。

>缺点：

    引入单一故障点；简介通信导致性能下降

>区分于：

    Facade，Facade只是为模块或系统定义一个较简单的接口，方便使用没有添加任何额外的功能

## Prototype（原型）模式

>特点：

    一种基于现有对象模版，通过克隆方式创建对象的模式。

>实现：

    书上给出了Object.create、类寄生式和直接prototype赋值三种方法。

## Command（命令）模式

>特点：

    提供一种分离职责的手段，这些指责包括从执行命令的任何地方发布命令以及将该指责转而委托给不同的对象

## Facade（外观）模式

>特点：

    结构型模式，为更大的代码体提供了一个方便的高层次接口，能够隐藏其底层的真实复杂性

>举例：

    jQuery

>缺点：

    必须确定Facade提供给实现的抽象是否含隐形成本，所以要试着了解涉及的任何性能成本，并确认是否值得抽象。

## Factory（工厂）模式

>特点：

    提供一个通用的接口来创建对象，可以指定我们所希望创建的工厂对象的类型，适用于对象创建过程相对比较复杂的情况。

>缺点：

    应用错误会给应用程序带来大量不必要的复杂性，因为对象创建的过程是藏身接口之后抽象出来的，所以单元测试也可能带来问题。

>升级：

    Abstract Factory（抽象工厂），用于封装一组具有共同目标的单个工厂。（感觉更常用一些）

## Mixin模式

>特点：

    继承Mixin通过拓展收集功能，目的是函数复用。（个人觉得和jQuery里的extend函数有些接近，算是简化版的吧）

>优点：

    一个应用程序在各个对象实例中共享行为时，可以在Mixin中维持这种共享功能，以轻松避免任何重复（函数复用）

>缺点：

    会导致原型污染和函数起源方面的不确定性

## Decorator（装饰者）模式

>特点：

    结构型设计模式，旨在促进代码复用，与Mixin类似。并不严重依赖于创建对象的方式，而是关注拓展其额外功能。

>升级or分类（？）：

    不是很懂原作上写想表达啥意思，希望有大佬指教。。。。伪经典Decorator，抽象Decorator与jQuery的Decorator

>优点：

    对象可以被新行为包装或修饰，然后可以继续被使用，而不用担心被修改的基本对象。在一个更广泛的上下文中，这种模式也使我们不必依靠大量的子类来获得同样的好处

>缺点：

    如果管理不当，可能会极大地复杂化应用程序架构，因为向我们的命名空间引入了很多小型但类似的对象。

## Flyweight（亨元）模式

>特点：

    经典的结构型解决方案，旨在通过与相关的对象共享尽可能多的数据来减少应用程序中内存的使用，而不是在每一个对象都存储相同的数据。

>应用分类：

    1、数据层：例如图书馆管理系统中的书籍是内部数据对象，借书情况是外部对象，从而减少内存，而不是把所有的数据都放在书籍对象里（说到这觉得和数据库的内外模式好像）
    2、DOM层：Flyweight用作中央事件管理器，也就是传说中经典的js性能问题--事件委托。

## 模块化的JavaScript设计模式（以下均为模块规范）

### AMD

>特点：

    异步模块定义（AMD）的整体目标是提供模块化的JavaScript解决方案。

>关键概念：

    1、用于模块定义的define方法
    2、用于处理依赖加载的require方法

>加载器：

    1、RequireJS
    2、curl.js

>优势：

    1、AMD可以加载任意格式的内容（包括文本文件和HTML）。
    2、封装模块定义，可以避免全局命名空间被污染。
    3、没有跨域、本地或调试的问题，也不依赖与服务器端工具。大多数AMD加载支持浏览器中的加载模块，无需构建流程。

### CMD

>sea.js,玉伯，懒加载，依托于AMD，浏览器端规范

    待研究哦

### CommonJS

>特点：

    建议指定一个简单的API来声明在浏览器外部工作的模块（如服务器上），试图包含IO、文件系统、promise等，与AMD不同的是模块周围通常是没有函数封装器的（所以看不到define）

>加载器：

    Node等

>优势：

    更适用于服务器端开发，假定同步行为。

### es 6

>前言：

    话说这个import和export只是用过理解得不是那么透彻，嗯嗯。。。。，待研究

### UMD

>前言：

    用于插件的AMD和CommonJS的兼容模块，是一种实验模块格式，嗯嗯。。。也待研究